[
  {
    "idx": 1,
    "title": "객체지향 프로그래밍(Object Oriented Programming)이란?",
    "line_1": "객체지향 프로그래밍이란 모든 것을 상태(attribute)인 변수와 행위(behavior)인 메소드를 가진 객체로 바라보는 방법론입니다.",
    "line_2": "이 방법론은 해당 객체들 간의 상호작용을 통해 프로그래밍을 작동 시킵니다.",
    "line_3": "객체지향 프로그래밍의 특징적인 요소로는 캡슐화, 상속, 다형성이 있습니다.",
    "line_4": "장점으로는 가독성 및 재사용성에 의한 개발시간 단축 등이 있습니다.",
    "line_5": "단점으로는 다중 상속 등이 되면 복잡해져서 파악하기 어려워집니다.",
    "voice_ids": 1
  },
  {
    "idx": 2,
    "title": "캡슐화(Encapsulation)란?",
    "line_1": "객체지향 프로그래밍에서 캡슐화는 2가지 측면을 갖습니다.",
    "line_2": "첫번째는 객체의 상태와 행위를 하나로 묶는 행위입니다.",
    "line_3": "비슷한 내용의 변수와 메소드를 같이 묶으면 코드의 유지보수가 편리해집니다.",
    "line_4": "두번째는 객체의 내용을 외부로부터 숨깁니다.",
    "line_5": "이것으로 불필요한 데이터의 접근 및 수정 등을 막을 수 있습니다.",
    "voice_ids": 2
  },
  {
    "idx": 3,
    "title": "상속(Inheritance)이란?",
    "line_1": "객체지향에서 상속이란 기존의 객체에 기능을 추가하거나 재정의하여 새로운 객체에 정의하는 것입니다.",
    "line_2": "새로운 객체가 상속을 이용하면 기존 객체의 상태와 행위를 전부 가지게 됩니다.",
    "line_3": "기존의 객체를 부모 객체, 새로운 객체를 자식 객체라고 부르기도 합니다.",
    "line_4": "장점으로는 객체를 재활용하기 편합니다.",
    "line_5": "단점으로는 상속 횟수가 많아질 수록 가독성과 유지보수가 복잡해집니다.",
    "voice_ids": 3
  },
  {
    "idx": 4,
    "title": "다형성(Polymorphism)이란?",
    "line_1": "객체지향에서의 다형성이란 하나의 객체가 여러가지 타입을 가질 수 있는 것을 말합니다.",
    "line_2": "오버라이딩(Overriding), 오버로딩(Overloading)이 기본적인 예에 속합니다.",
    "line_3": "오버라이딩은 상속한 부모 객체의 메소드를 재정의해 덮어씌우는 것을 뜻합니다.",
    "line_4": "오버로딩은 동일한 이름의 메소드를 인자만 다르게 해서 여러 개 정의하는 것을 뜻합니다.",
    "line_5": "장점은 많은 메소드를 이름을 다르게 해서 정의할 필요가 없어지는 편리함이 있습니다.",
    "voice_ids": 4
  },
  {
    "idx": 5,
    "title": "메모리(Memory) 구조는?",
    "line_1": "프로그램의 메모리 구조는 실행할 코드, 데이터 영역, 동적 할당: 힙(Heap), 지역 변수 및 매개 변수: 스택(Stack)으로 나뉩니다.",
    "line_2": "실행할 코드 영역은 변경 되어서는 안되는 영역으로 프로그램이 종료될 때가지 해제되지 않습니다.",
    "line_3": "데이터 영역에는 전역 변수 및 정적 변수가 들어가며 마찬가지로 프로그램이 종료될 때까지 해제되지 않습니다.",
    "line_4": "동적 할당: 힙 영역에는 동적으로 할당되는 변수가 할당 되며 사용이 없어졌을 때 알아서 해제되거나(예: Unity의 GC) 사용자가 직접 해제할 수 있습니다.",
    "line_5": "지역 변수 및 매개 변수: 스택 영역에는 메소드가 호출될 때 사용 되는 인자 및 내부 변수가 저장 되며 해당 메소드가 종료될 때 해제됩니다.",
    "voice_ids": 5
  },
  {
    "idx": 6,
    "title": "메모리(Memory)란?",
    "line_1": "메모리는 컴퓨터의 저장공간을 의미합니다.",
    "line_2": "프로그램은 메모리에 저장되어 실행 되며, 데이터와 코드 등의 정보를 저장할 수 있습니다.",
    "line_3": "컴퓨터가 자동으로 데이터를 할당하며, 프로그래머가 메모리에 데이터를 직접 할당할 수도 있습니다.",
    "line_4": "메모리 관리는 컴퓨터 프로그래밍에 있어서 중요한 요소입니다.",
    "line_5": "메모리가 제대로 관리되지 않으면 메모리 누수, 버그, 메모리 부족으로 인해 프로그램이 제대로 작동하지 않을 수도 있습니다.",
    "voice_ids": 6
  },
  {
    "idx": 7,
    "title": "스택(Stack)이란?",
    "line_1": "스택(Stack)은 메모리의 한 영역으로, 데이터를 임시로 저장하기 위한 자료구조입니다.",
    "line_2": "스택은 후입선출(LIFO, Last In First Out)의 원리에 따라 동작합니다.",
    "line_3": "함수 호출 시 함수의 지역변수, 매개변수, 반환주소 등의 정보는 스택에 순서대로 저장됩니다.",
    "line_4": "이렇게 스택에 저장된 정보는 함수가 실행을 마치고 반환되면 스택에서 제거됩니다.",
    "line_5": "스택에는 데이터를 넣는 작업을 푸시(Push)라고 하고, 데이터를 빼내는 작업을 팝(Pop)이라고 합니다.",
    "voice_ids": 7
  },
  {
    "idx": 8,
    "title": "스택 포인터(Stack Pointer)란?",
    "line_1": "스택 포인터(Stack Pointer)는 스택의 가장 위쪽 데이터의 위치를 가리키며, 데이터의 삽입 및 삭제는 스택 포인터를 이용하여 수행됩니다.",
    "line_2": "데이터를 삽입할 때는 스택 포인터를 먼저 증가시킨 다음, 그 위치에 데이터를 저장합니다.",
    "line_3": "데이터를 삭제할 때는 스택 포인터를 먼저 감소시킨 다음, 그 위치에 있는 데이터를 반환하거나 삭제합니다.",
    "line_4": "스택의 맨 위에 있는 데이터를 가리키기 때문에, 스택이 비어있을 때는 스택 포인터는 스택의 가장 아래쪽 주소를 가리키고 있습니다.",
    "line_5": "스택 포인터는 일반적으로 하드웨어 레지스터에 저장되며, 프로세서가 스택 연산 명령을 실행할 때마다 스택 포인터가 자동으로 증가하거나 감소합니다.",
    "voice_ids": 8
  },
  {
    "idx": 9,
    "title": "스택 오버플로우(Stack Overflow)란?",
    "line_1": "스택 오버플로우(Stack Overflow)는 스택에 저장할 수 있는 데이터의 양을 초과하여 데이터를 삽입하려고 할 때 발생하는 오류입니다.",
    "line_2": "스택은 한정된 크기의 메모리 영역을 사용하므로, 스택에 쌓인 데이터가 일정 크기를 초과하면 스택 오버플로우가 발생합니다.",
    "line_3": "스택 오버플로우는 일반적으로 프로그래밍 실수로 인해 발생하거나 또는 버퍼 오버런(Buffer overrun)과 같은 보안 취약점으로 인해 스택 오버플로우가 발생할 수도 있습니다.",
    "line_4": "스택 오버플로우가 발생하면, 시스템은 일반적으로 프로그램을 강제 종료시키거나 예기치 않은 동작을 수행하게 됩니다.",
    "line_5": "스택 오버플로우를 방지하기 위해서는, 스택의 크기를 적절히 조절하거나, 재귀 함수 등에서 무한히 호출되지 않도록 적절한 조치를 취해야 합니다.",
    "voice_ids": 9
  },
  {
    "idx": 10,
    "title": "스택 언더플로우(Stack Underflow)란?",
    "line_1": "스택 언더플로우(Stack Underflow)는 스택에서 데이터를 삭제하려 할 때, 스택에 데이터가 없는 상태에서 삭제를 시도하면 발생하는 오류입니다.",
    "line_2": "스택 언더플로우는 스택의 최하단 위치까지 데이터가 삭제되는 경우에 발생합니다.",
    "line_3": "스택 언더플로우는 일반적으로 프로그래밍 실수로 인해 발생합니다.",
    "line_4": "스택 언더플로우가 발생하면, 일반적으로 시스템은 프로그램을 강제 종료시키거나 예기치 않은 동작을 수행하게 됩니다.",
    "line_5": "스택 언더플로우를 방지하기 위해서는, 스택에서 데이터를 삭제하기 전에 스택이 비어있는지 체크하거나, 스택을 사용하기 전에 스택 포인터를 초기화해야 합니다.",
    "voice_ids": 10
  },
  {
    "idx": 11,
    "title": "컴퓨팅 유닛(Compute Units)이란?",
    "line_1": "컴퓨팅 유닛(Compute Units)는 컴퓨팅 디바이스(예: 그래픽 카드, 프로세서)에서 병렬 처리를 수행하는 작은 프로세서 유닛입니다.",
    "line_2": "각각의 컴퓨팅 유닛은 여러 개의 스레드를 처리할 수 있으며, 다수의 컴퓨팅 유닛을 함께 사용하여 대규모 병렬 처리를 수행할 수 있습니다.",
    "line_3": "이를 통해 컴퓨팅 디바이스의 처리량을 대폭 높일 수 있으며, 고성능 컴퓨팅과 딥러닝 등의 분야에서 활용됩니다.",
    "line_4": "",
    "line_5": "",
    "voice_ids": 11
  },
  {
    "idx": 12,
    "title": "힙(Heap)이란?",
    "line_1": "힙(Heap)은 프로그램이 실행되는 동안 사용되는 동적 메모리 영역입니다.",
    "line_2": "프로그램이 실행되면, 힙 메모리는 운영체제로부터 할당받아 사용됩니다.",
    "line_3": "힙 메모리는 스택과 달리 크기가 가변적이며, 사용자가 필요에 따라 메모리를 동적으로 할당하고 해제할 수 있습니다.",
    "line_4": "힙 메모리는 보통 전역 변수나 정적 변수와 같이 프로그램의 실행 중에 유지되는 데이터를 저장하기 위해 사용됩니다.",
    "line_5": "힙 메모리는 스택과 달리 크기가 가변적이므로, 메모리 누수(memory leak)와 같은 문제가 발생할 수 있습니다.",
    "voice_ids": 12
  },
  {
    "idx": 13,
    "title": "메모리 누수(memory leak)란?",
    "line_1": "메모리 누수(memory leak)는 프로그램에서 동적으로 할당한 메모리를 프로그램이 더 이상 사용하지 않으면서도 할당된 메모리를 해제하지 않아 발생하는 문제입니다.",
    "line_2": "즉, 프로그램이 사용하지 않는 메모리가 계속해서 쌓이는 현상을 의미합니다.",
    "line_3": "예를 들어, 동적으로 할당한 메모리를 해제하지 않거나, 메모리를 여러 번 할당하고 해제하지 않는 경우에 발생할 수 있습니다.",
    "line_4": "또한, 메모리를 할당한 후에 해당 메모리에 대한 포인터를 잃어버리는 경우에도 메모리 누수가 발생합니다.",
    "line_5": "메모리 누수는 메모리 사용량이 계속해서 증가하면서, 시스템의 성능을 저하시키고, 시스템이 충돌하는 원인이 될 수 있습니다.",
    "voice_ids": 13
  },
  {
    "idx": 14,
    "title": "데이터 드리븐(Data-driven)이란?",
    "line_1": "데이터 드리븐(Data-driven)은 데이터를 중심으로 프로그램이 동작하는 방식을 말합니다.",
    "line_2": "데이터 드리븐 방식은 데이터와 로직을 분리하여 데이터가 변경되어도 로직이 유지보수하기 쉬워지는 장점이 있습니다.",
    "line_3": "데이터 드리븐 방식을 사용하는 프로그램은 데이터베이스, 파일, API 등에서 데이터를 읽어와서 처리하는 방식으로 동작합니다.",
    "line_4": "데이터가 변경되면 해당 데이터를 사용하는 부분만 수정하면 되므로, 전체 코드를 수정할 필요가 없어서 유지보수성이 좋습니다.",
    "line_5": "",
    "voice_ids": 14
  },
  {
    "idx": 15,
    "title": "메모리를 최적화 하는 법은?",
    "line_1": "메모리 누수(Memory Leak) 방지: 사용하지 않는 메모리를 해제하지 않으면 시스템 메모리에 누적되어 시스템 성능을 저하시키므로, 메모리 누수를 방지하는 것이 중요합니다.",
    "line_2": "메모리 캐싱: 반복적으로 사용되는 데이터를 캐시에 저장하여 메모리 접근 시간을 줄이고 성능을 향상시킵니다.",
    "line_3": "메모리 프리페칭(Memory Prefetching): 미리 필요한 데이터를 미리 메모리에 로드하여 프로그램 실행 시간을 줄입니다.",
    "line_4": "메모리 압축(Memory Compression): 사용하지 않는 메모리를 압축하여 메모리 용량을 줄이고 시스템 성능을 향상시킵니다.",
    "line_5": "메모리 구조 개선: 메모리 구조를 최적화하여 메모리 접근 시간을 줄이는 것도 메모리 최적화에 중요한 요소 중 하나입니다.",
    "voice_ids": 15
  }
]
